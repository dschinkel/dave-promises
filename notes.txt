Webstorm Debugging - EMCAScript 6

    Ways to setup mocha debugging for es6 using Webstorm Debug

        - transpile using sourcemaps via guilp tasks, then setup mocha debug task in webstorm to run the transpiled files
        - transpile using sourcemaps using Webstorm's built-in watcher tool for babel, then setup mocha debug task in webstorm to run the transpiled files

        What you'll need either case:

            - the babel cli installed
                - npm install --save-dev babel-cli
            - npm install --save-dev babel-preset-es2015
                - if you're using jsx, you'll need babel-preset-react plugin instead
            - add a .babelrc file and in it put:

                {
                "presets": ["es2015"]
                }

Notes:

    So when you run webstorm debug lets say for straight node debugging on a file or mocha, it's not using your gulp tasks.  So, when you have something like
    require('babel-core/register'); at the top of your gulpfile, that's only referenced and used when you run tests from the command-line

    When you run debug on es6 code using webstorm debug, then debug is going to just look at the transpiled files
    You can transpile the files either with a webstorm babel watcher setup in Preferences or you can just run your own gulp task to transpile them to a folder like
    build or dist and then have the mocha debug or node debug configuration look at the transpiled code, that is...look at the build or dist folder and run the debug on
    those transpiled js files

    For some reason, I'm not able to get mocha debug to hit my original files using sourcemaps, the debug works but it's hitting my transpiled code.

    I got debug working on build and remember that I had to change in my test, referencing the Imp using import Impl from './davePromiseImpl' since I was
    setting up my debug to work over my build folder so I was debugging on my test.js file from my debug folder so it had to be relative to my build folder and also had to
    change the guilpfile mocha src to the build folder: return gulp.src(['build/*-test.js'], { read: false })

https://github.com/stefanwalther/es6-debug-webstorm - nice github page on how this guy does it

http://stackoverflow.com/questions/30743352/webstorm-debugging-mocha-tests-written-in-es6
    http://blog.jetbrains.com/webstorm/2015/05/ecmascript-6-in-webstorm-transpiling/#babelfilewatcher
        - File watcher is a WebStorm built-in tool that allows you to automatically run some command-line tools on file changes
            - For Babel and Traceur WebStorm has pre-configured File watchers

    http://babeljs.io/docs/setup/#webstorm
    http://www.html5rocks.com/en/tutorials/developertools/sourcemaps
        https://www.npmjs.com/package/gulp-sourcemaps

Debugging Node file Directly in Webstorm

        http://stackoverflow.com/questions/29170589/debug-nodejs-es6-app-webstorm/33045275#33045275 - this is for node debugging directly on a file, not using mocha


Kinda cool, debug a file instantly with Chrome Tools via babel https://www.npmjs.com/package/babel-node-debug

/*
     If you have the answer, you call the callback with it
     If you don't have the answer you push the callback to an array
     Then once you have the answer you call all the callbacks on the array with the answer
     The callbacks in the array are the ones waiting for the answer

     A promise is just an object capable of calling callbacks when an answer is made (resolved).
     If the answer is known, you call immediately
     Otherwise you add the callback to a list of waiting callbacks
     Then just performs the logic
 */

export default callback => {
    var waiting = [];
    var result;

    callback(...args => {
        result = args;
        waiting = waiting.filter(callback => callback(...result));
    });

    return {
        then(callback) {
            result ? callback(...result) : waiting.push(callback);
            return this;
        }
    };
};

https://github.com/esnext/es6-module-transpiler/issues/85 (on exports.default that Dave is using)

- if you run tests and they stall in webstorm's runner, check the debug tab, there might be an error that doesn't necessary print out in the console next to the test runner